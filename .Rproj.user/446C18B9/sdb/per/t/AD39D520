{
    "collab_server" : "",
    "contents" : "#############################################################################################################################\n# This version features:\n# 1. uses rpivotTable package to do generate pivot table, slice data in the table and generate charts for the table\n# 2. download summary data to csv file ( this NOT working on shiny.io error:cannot find x-path element!)\n# 3. filter data by date columns\n# 4. copyright footer in ui page\n# 5. add css style for datecontrol ui row\n# \n# ----- sharing the app -----\n# Github repo: \n# How to setup: https://help.github.com/articles/adding-an-existing-project-to-github-using-the-command-line/\n# Quick Reference: https://readwrite.com/2013/09/30/understanding-github-a-journey-for-beginners-part-1/\n# https://github.com/catelinn/a-simple-pivot-data-app\n#\n# for web user to download and test the app in their computer (requirements: R/RStudio IDE, shiny package)\n# the file is saved on https://gist.github.com (my Github account)\n# runGist(\"edaa916edf572b3a9db331ab6ac7ce74\")  \n#############################################################################################################################\n\n# PENDING - validate input$daterange(i) - no dates can be selected outside of the range \n# PENDING - checkbox to choose show date columns data as date, month or year \n# PENDING - retest rvest() for rpivotTable data on Shiny.io when solution is found! (convert html table to data frame)\n# PENDING - dashboard for the app! (read the javascript based widget tutorial for further study)\n\n\n#############################################################\n#  Key References\n#############################################################\n# shiny function reference\n# https://shiny.rstudio.com/reference/shiny/latest/\n\n# create loop for multiple inputs \n# (In this App, create multiple date range ui depending on number of date columns selected)\n# https://stackoverflow.com/questions/42169380/shiny-renderui-with-multiple-inputs\n\n\n# endoding issue for Chinese character used on Winrundows:\n# https://github.com/vnijs/radiant/issues/25\n\n\n# use rio package to do file import/export regardless of type:\n# https://cran.r-project.org/web/packages/rio/README.html\n\n\n# if problem with package versions:\n# remove.packages() and then install.packages(p, dependencies = TRUE)\n\n# verify if a column can be converted to date\n# https://stackoverflow.com/questions/18178451/is-there-a-way-to-check-if-a-column-is-a-date-in-r\n\n# CSS selector reference (how to remove uis under daterangescontrol div?)\n# https://www.w3schools.com/cssref/css_selectors.asp\n\n# for loop / lapply for observeEvent in Shiny:\n# https://stackoverflow.com/questions/40038749/r-shiny-how-to-write-loop-for-observeevent\n\n# how to delete delements in a list:\n# https://stackoverflow.com/questions/652136/how-can-i-remove-an-element-from-a-list\n\n# share the app and allow runURL, runGist, runGitHub:\n# https://shiny.rstudio.com/reference/shiny/latest/runUrl.html\n# https://shiny.rstudio.com/tutorial/lesson7/\n\n\nlibrary(\"shiny\")\nlibrary(\"shinythemes\") # choose shiny ui themes\nlibrary(\"DT\") # Datatable \nlibrary(\"rsconnect\") # deploy to shinyapps.io\nlibrary(\"shinyjs\") # use toggle button from shinyJS pacakage\nlibrary(\"readxl\") # load excel file (http://readxl.tidyverse.org/) \nlibrary(\"data.table\") # setattr() to override data table\nlibrary(\"rpivotTable\")\nlibrary(\"stats\")\nlibrary(\"zoo\") # to use as.Date() on numeric value\n\n# the following is for probable success of running rvest functions on shiny.io, which turned out negative. \n# why rvest (to turn html table to data frame so I can download it to a file) cannot work properly on shiny.io, it's pending for resolution\nlibrary(\"rvest\") \nlibrary(\"magrittr\")\nlibrary(\"htmlwidgets\")\nlibrary(\"htmltools\")\n\n# set global options for shiny app\noptions(\n  # show shiny error debug tool in RStudio\n  shiny.error = browser,\n  #print messages sent between the R server and the web browser client to the R console (for debugging)\n  shiny.trace = TRUE,\n  # show shiny reactivity logs by pressing Ctrl + F3:\n  shiny.reactlog=TRUE\n)\n\n\nui = fluidPage(\n  \n  theme = shinytheme(\"cerulean\"),\n  \n  tags$head(\n    tags$link(rel = \"stylesheet\", type = \"text/css\", href = \"style.css\")\n  ),\n  \n  navbarPage(\"myApp\",\n             \n             tabPanel(\"Data\", \n                      \n                      fluidPage(\n                        fluidRow(\n                          column(4,\n                                 # file upload div\n                                 fileInput(\"file\", \"Choose a file (text/csv or excel)\",\n                                           # limit the file extention to the following:\n                                           accept=c(\n                                             \"text/csv\", \n                                             \"text/comma-separated-values,text/plain\", \n                                             \".csv\",\n                                             \".xls\",\n                                             \".xlsx\",\n                                             \"application/vnd.ms-excel\"))\n                          ),\n                          column(4, \n                                 # show ui for upload file control\n                                 uiOutput(\"ui\")\n                          ),\n                          column(4,\n                                 # no choices before a file uploaded\n                                 uiOutput(\"columnscontrol\")\n                          )\n                          \n                        ),\n                        \n                        \n                        fluidRow(\n                          div( class = \"daterow\",\n                               column(4,\n                                      uiOutput(\"datecolscontrol\")),\n                               \n                               column(6,\n                                      uiOutput(\"daterangescontrol\"))\n                          )\n                        ),\n                        \n                \n                        dataTableOutput(\"datatbl\"),\n                        \n                        # print console for debugging (delete after completion)\n                        #verbatimTextOutput(\"print_con\")\n                        \n                        br(),\n                        br(),\n                        br(),\n                        \n                        # add footer div to bottom\n                        withTags({\n                          div(class = \"footer\", \n                              HTML(\"<p>&copy; 2017 Catelinn Xiao</p>\"))\n                        })\n                        \n                      )),\n             \n             \n             \n             tabPanel(\"Pivot Table\",     \n                      \n                      #DOWNLOAD DOESN'T WORK RIGHT NOW ON SHINY.IO as rvest not running correctly \n                      downloadButton(\"downloadData\", \"Download\"),\n                      \n                      rpivotTableOutput(\"pivot\")\n                      \n                      \n             )\n             \n             \n             # tabPanel(\"Summary Data\",\n             #          dataTableOutput(\"SummaryTable\") \n             #          )\n             \n             \n  )# end of navbarPage\n)  #end of fluidPage (ui)\n\n\n\n# server\nserver = function(input, output, session) {\n  \n  \n  #########################################################\n  #1.  upload & datatable output\n  #########################################################\n  \n  # create dataset reactive objects\n  dt <- reactiveValues()\n  \n  # reset all uis depending on the uploaded file\n  observeEvent(input$file, {\n    \n    # reset inputs\n    \n    # reset ui outputs\n    # reset(\"ui\")\n    # reset(\"columns\")\n    \n    \n    # reset reactive values\n    dt$data = NULL\n    dt$df = NULL\n    dt$cols = NULL\n    dt$rows = NULL\n    dt$summary = NULL\n    dt$colchoices = NULL\n    dt$datecols = NULL\n    if (length(dt$range) > 0) { mapply(function(i) dt$range[[i]] <- c(NULL, NULL), 1:length(dt$range)) }\n    if (length(dt$range_check) > 0) { mapply(function(i) dt$range_check[i] <- NULL, 1:length(dt$range_check))}\n    \n    removeUI(selector = \"div#columns_div\")\n    removeUI(selector = \"div#datecols_div\")\n    \n    # remove all <div> elements indside <div>#daterangescontrol:\n    removeUI(selector = \"div#daterangescontrol *\")\n  })\n  \n  \n  # https://groups.google.com/forum/#!topic/shiny-discuss/Mj2KFfECBhU\n  chooseFile <- eventReactive(input$file, {\n    \n    # input$file will be NULL initially. After the user selects\n    # and uploads a file, it will be a data frame with 'name',\n    # 'size', 'type', and 'datapath' columns. The 'datapath'\n    # column will contain the local filenames where the data can\n    # be found.\n    file <- input$file\n    \n    # if the file uploaded\n    if (!is.null(file)) {\n      \n      # determine file format and assign it chooseFile$suf\n      pattern <- \"\\\\.[[:alnum:]]*$\"\n      ### regexpr() returns integer of the starting position of the first match or -1 if there is none\n      ### regmatches() extract the matched substrings from match data obtained by regexpr\n      suf <- tolower(regmatches(file$name, regexpr(pattern, file$name)))\n      \n      # return objects in the list of chooseFile\n      return(list(path = file$datapath, suf = suf))\n      \n    } else{\n      # if no file uploaded, NULL\n      return(NULL)\n    }\n    \n  })\n  \n  \n  # generate upload file control ui once file uploaded\n  observe ({\n    \n    # file will get all the columns (path, suf) in chooseFile()\n    file <- chooseFile()\n    req(file)\n    \n    # render ui control for excel file uploaded\n    if (file$suf %in% c(\".xls\", \".xlsx\")) {\n      # excel file control\n      file.rename(file$path, paste0(file$path,file$suf))\n      sheets <- excel_sheets(paste0(file$path,file$suf))\n      output$ui <- renderUI({\n        tagList(\n          selectInput(\"sheet\", label = \"Select a sheet:\", choices = sheets),\n          textInput(\"arg\", label = \"Additional arguments:\", value = \" \"),\n          br(),\n          actionButton(\"readF\", \"Update\"))\n      })\n    }\n    \n    # render ui control for text/csv file uploaded\n    if (file$suf %in% c(\".txt\", '.csv') ) {\n      # text/csv file control\n      output$ui <- renderUI({\n        tagList(\n          p(\"Import first row of data as header\"),\n          textInput(\"sep\", label = \"Seperator:\", value = \",\"),\n          textInput(\"quote\", label = \"Quote:\", value = \"\\\"\"),\n          textInput(\"arg\", label = \"Additional arguments:\", value = \" \"),\n          br(),\n          actionButton(\"readF\", \"Update\"))\n      })\n    }\n    \n  })\n  \n  \n  # read data to dt$data with arguments set above when action button pressed\n  observeEvent (input$readF, {\n    \n    file <- chooseFile()\n    \n    # equivalent to if(!is.null(file)) - make sure file uploaded before the rest of codes run\n    req(file)\n    \n    # pop data from excel sheet\n    if (file$suf %in% c(\".xls\", \".xlsx\")) {\n      sheet <- input$sheet\n      req(sheet)\n      req(input$arg)\n      if(input$arg %in% c(' ', '')){\n        f <- read_excel(paste0(file$path,file$suf), sheet)\n      } else {\n        expr <- paste('read_excel(paste0(file$path,file$suf), sheet,', input$arg, ')', sep = '')\n        print(expr)\n        f <- eval(parse(text = expr))\n      }\n      \n      # dropdown filter is cut off if columns are not of class factor or numeric/integer\n      # also it's easier to convert factor to character for as.Date() later in this App (align with csv upload)\n      # so convert non-number columns to factor:\n      factor_cols <- !(lapply(f, class) == \"numeric\" | lapply(f, class) == \"integer\" )\n      f[,factor_cols] <- lapply(f[,factor_cols], as.factor)\n      dt$data <- f\n    }\n    \n    # pop data from txt/csv file\n    if (file$suf %in% c(\".txt\", '.csv') ) {\n      req(input$arg)\n      if(input$arg %in% c(' ', '')){\n        f <- read.csv(file$path, \n                      header = TRUE, \n                      sep = input$sep,  \n                      quote = input$quote)\n        dt$data <- f\n      } else {\n        # datapath of the file (change \"\\\\\" to \"/\")\n        expr1 <- paste(\"\", gsub(\"\\\\\", \"/\", file$path, fixed = TRUE), \"\", sep = \"\")\n        \n        # prepare the strings of arguments for read.csv()\n        expr2 <- paste(expr1,\n                       paste(\"header = input$header\"),\n                       paste(\"sep=\", paste(\"\", input$sep, \"\", sep = \"\")),\n                       paste(\"quote=\", paste(\"\", input$quote, \"\", sep = \"\")), \n                       input$arg, sep = \"\")\n        print(expr2)\n        \n        # combine read.csv() with arguments\n        expr <- paste(\"read.csv2(',expr2,')\", sep = \"\")\n        print(expr)\n        \n        # parse and run the expr and get the dataset\n        f <- eval(parse(text = expr))\n        dt$data <- f\n      }\n    }\n    \n    # get the col names of the dataset and assign them to a list\n    dt$colchoices <- mapply(list, names(dt$data))\n    \n    \n    # update datecols choices with those columns can be converted to Date only:\n    dt$date_ok = sapply(dt$data, function(x) !all(is.na(as.Date(as.character(x), format = \"%Y-%m-%d\"))))\n    dt$datecolchoices = colnames(dt$data[dt$date_ok])\n    \n    \n    # render columnscontrol with empty data\n    output$columnscontrol <-  renderUI({\n      # render column group checkbox ui after loading the data\n      # tags#div has the advantage that you can give it an id to make it easier to reference or remove it later on\n      tags$div(id = \"columns_div\", \n               checkboxGroupInput(\"columns\", \"\", choices = dt$colchoices, selected = dt$colchoices))\n    })\n    \n    # render datecolscontrol with empty data\n    output$datecolscontrol <- renderUI({\n      tags$div(id = \"datecols_div\",\n               selectInput(\"datecols\", \"Filter data by dates):\", choices = NULL, multiple = TRUE, selected = NULL))\n    })\n    \n    \n  }) # end of observeEvent(update button pressed})\n  \n  \n  # convert these columns to Date in the dataset (require dt$datecolchoices, dt$date_ok)\n  # this is called whenever dt$data is loaded, in case the new uploaded dataset has same dt$cols, dt$datecolchoices as the previous loaded dataset\n  observeEvent(dt$data, {\n    req(dt$datecolchoices)\n    req(dt$date_ok)\n    dt$data[dt$date_ok] = lapply(dt$data[dt$date_ok], function(x) as.Date(as.character(x)))\n  })\n  \n  \n  # the other reactivity on dt$cols is input$file (when new file uploaded, dt$data and dt$cols set to NULL)\n  # so that the following line set apart the reactivity of input$columns on dt$cols\n  observeEvent(input$columns, { \n    dt$cols <- input$columns\n    #dt$df <- dt$data[dt$cols]\n  }, ignoreNULL = FALSE)\n  \n  \n  \n  # on change of columns selected\n  observeEvent(dt$cols, {\n    \n    # update dt$df (table data)\n    dt$df = dt$data[dt$cols]\n    \n    # update input$datecols choices with available date columns\n    choices = dt$datecolchoices[dt$datecolchoices %in% dt$cols]\n    updateSelectInput(session, \"datecols\", \"Filter data by dates:\", choices = choices, selected = NULL)\n    \n  })\n  \n  tbldata <- reactive({\n    \n    req(dt$df)\n    \n    # table data with date range filters or not\n    if ( length(input$datecols) > 0 ) {\n      \n      # to avoid error when dt$range_check is not loaded yet (otherwise, dt$filtered_ind * NULL result in error)\n      # so make sure first range_check is available before the loop over the rest of range_check\n      req(dt$range_check)\n      dt$filtered_ind = as.integer(dt$range_check[[input$datecols[1]]])\n      \n      # loop over range_check after the first one\n      lapply( input$datecols[-1],\n              FUN = function(x) {\n                dt$filtered_ind = as.integer(dt$range_check[[input$datecols[1]]]) * dt$range_check[[x]]\n              }\n              \n      ) # end of lapply()\n      \n      dt$df[as.logical(dt$filtered_ind),]\n    } \n    else { dt$df }\n    \n  })\n  \n  # render output$datatbl \n  \n  output$datatbl <- DT::renderDataTable({\n    \n    D = tbldata()\n    \n    # which columns not for search in datatable filter\n    dt$notforsearch = sapply(which(names(D) %in% dt$datecolchoices), function(x) x-1)\n    \n    # datatable\n    datatable(D, rownames = FALSE,\n              # column filter on the top\n              filter = 'top',\n              # autoWidth\n              options = list(autoWidth = TRUE, \n                             # disable date columns for filter - not working yet (awaiting stackoverflow reply)\n                             columnDefs = list(list( targets = dt$notforsearch, searchable = FALSE)))\n    )\n  })\n  \n  # set apart input$datecols and dt$datecols, so that when a new file uploaded, dt$datecols can be set to NULL right away\n  observeEvent(input$datecols, {\n    dt$datecols = input$datecols\n  }, ignoreNULL = FALSE)\n  \n  \n  # for all new file uploaded, generate daterange uis per selected input$datecols\n  observeEvent(dt$datecols, {\n    \n    # render daterange ui(s) per selected datecols\n    output$daterangescontrol <- renderUI({\n      \n      # when input$datecols is NULL, no daterangecontrol ui and reset all dt$range[[x]] to original min/max\n      if (is.null(dt$datecols)) {\n        return(NULL)\n      }\n      \n      # otherwise\n      else {\n        \n        D = dt$df\n        \n        # whenever input$datecols change, start/end of daterange ui refresh to original state\n        output = tagList()\n        \n        for (x in dt$datecols) {\n          i = which(dt$datecols == x)\n          output[[i]]= tagList()\n          output[[i]][[1]] = tags$div(id = paste(\"dateranges_div\", i, sep = \"_\"),\n                                      dateRangeInput(paste0(\"daterange_\", x),\n                                                     paste(\"Date range of\", x),\n                                                     start = min(D[[x]]),\n                                                     end = max(D[[x]]))\n          )\n        }\n        # return output tagList() with ui elements\n        output\n      } # end of else{}\n    }) # end of renderUI\n  }, ignoreNULL = FALSE) # end of observeEvent\n  \n  \n  # here goes the codes for assigning input$daterange data to filter corresponding columns\n  \n  observe({\n    # loop observeEvent on input$daterange1, input$daterange2... \n    lapply( input$datecols,\n            \n            FUN = function(x) {\n              \n              # on change of input$daterange_x\n              observeEvent(input[[paste0(\"daterange_\", x)]], {\n                \n                # update reactive values to test whether this loop is working\n                dt$range[[x]] = input[[paste0(\"daterange_\", x)]]\n                \n                # filter dataset with the corresonding date column:\n                D = dt$df\n                dt$range_check[[x]] = D[[x]] >=  dt$range[[x]][[1]] & D[[x]] <= dt$range[[x]][[2]]\n                \n                ##################################################################\n                #  Validation not working, no error message (check stackoverflow)\n                ##################################################################\n                # shiny::validate(\n                #   need( dt$range[[x]][[1]] >= min(dt$data[[x]]), \"The start date cannot be earlier than the oldest date!\"),\n                #   need( dt$range[[x]][[2]] <= max(dt$data[[x]]), \"The end date cannot be later than the latest date!\")\n                # )\n                \n              }) # end of observeEvent\n            }\n    ) # end of lapply()\n    \n  })\n  \n  \n  # rows displayed in input$datatbl (the rendered data table)\n  observeEvent( input$datatbl_rows_all, { \n    dt$rows <- input$datatbl_rows_all\n  })\n  \n  \n  #########################################################\n  #2.  pivot table output\n  #########################################################\n  \n  pivotdata <- reactive({tbldata()[dt$rows,]})\n  \n  # Whenever the config is refreshed, call back with the content of the table\n  output$pivot <- renderRpivotTable({\n    \n    validate(need(pivotdata(), \"Please load data first. \"))\n    \n    rpivotTable(\n      \n      pivotdata(),\n      # this line will pass input$pivot innerHTML to input$myData \n      # (this is to generate HTML table and pass the HTML to rvest::html_table to convert to data frame, which now doesn't work on shiny.io)\n      onRefresh =\n        htmlwidgets::JS(\"function(config) {\n                        Shiny.onInputChange('myData', document.getElementById('pivot').innerHTML);\n  }\")\n    )\n})\n  \n  \n  # Clean the html of input$myData (rvest package) and store as reactive - NOT WORKING on shiny.io\n  observeEvent(input$myData,{\n    \n    # there are two tables in an rpivotTable, we want the second\n    dt$summary = input$myData %>%\n      read_html %>%\n      html_table(fill = TRUE) %>%\n      .[[2]]\n  })\n  \n  \n  # show df as DT::datatable\n  # output$SummaryTable <- DT::renderDataTable({\n  #   datatable(dt$summary, rownames = FALSE)\n  # })\n  \n  observeEvent(\"downloadData\", {\n    \n    output$downloadData <- downloadHandler(\n      filename = function() {\n        paste(\"data-\", Sys.Date(), \".csv\", sep=\"\")\n      },\n      content = function(file) {\n        write.csv(dt$summary, file)\n      }\n    )\n    \n  })\n  \n  \n  \n  #########################################################\n  # 3. print console\n  #########################################################\n  # output$print_con <- renderPrint({\n  #   \n  #   #req(input$daterange1)\n  #   #d = dt$df[dt$rows, dt$cols]\n  #   #date_ok = sapply(d, function(x) !all(is.na(as.Date(as.character(x), format = \"%Y-%m-%d\"))))\n  #   #cells = unlist(d[dt$datecols[[1]]], use.names = FALSE)\n  #   #d[date_ok] = lapply(d[date_ok], function(x) as.Date(as.character(x)))\n  #   list(str(dt$data), \n  #        #str(dt$df[dt$rows, dt$cols]),\n  #       #as.Date(as.character(cells))\n  #       #sum(unlist(dt$date_ok)),\n  #       #lapply(d[date_ok], function(x) as.Date(as.character(x)))),\n  #       #summary(dt$df),\n  #       str(dt$df),\n  #       #dt$date_ok,\n  #       #dt$datecolchoices,\n  #       paste(\"dt$notforsearch: \", paste(dt$notforsearch, collapse = \",\")),\n  #       paste(\"dt$filtered_ind: \", paste(dt$filtered_ind, collapse = \",\")),\n  #       paste(\"dt$range: \", list(dt$range)),\n  #       paste(\"dt$range_check: \", list(dt$range_check)),\n  #       paste(\"length of dt$range: \", length(dt$range)),\n  #       paste(\"input$daterange_visitdates: \", input$daterange_visitdates),\n  #       paste(\"dt$range_check[[1]] * dt$range_check[[2]]:\", paste(dt$range_check[[\"visitdates\"]] * dt$range_check[[\"editdates\"]], collapse = \",\")),\n  #       identical(dt$filtered_ind, dt$range_check[[\"visitdates\"]] * dt$range_check[[\"editdates\"]]),\n  #       paste(\"dt$range_start[['visitdates']]:\", dt$range_start[[\"visitdates\"]]),\n  #       paste(\"dt$datecolchoices: \", paste(dt$datecolchoices, collapse = \",\")),\n  #       paste(\"dt$datecols: \", paste(dt$datecols, collapse = \",\"))\n  #       #str(dt$df)\n  #       #min(dt$range[[1]][[1]]) >= min(dt$df[[dt$datecols[[1]]]]),\n  #       #max(dt$range[[1]][[2]]) <= max(dt$df[[dt$datecols[[1]]]]),\n  #       #html_structure(read_html(input$myData))\n  #   )\n  #})\n  \n  } # end of shiny server function\n\nshinyApp(ui = ui, server = server, options = options)\n\n",
    "created" : 1498018412458.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "501690609",
    "id" : "AD39D520",
    "lastKnownWriteTime" : 1498028620,
    "last_content_update" : 1498028620,
    "path" : "~/OneDrive/Study/My Shiny/a simple pivot data app/app.R",
    "project_path" : "app.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : true,
    "source_window" : "",
    "type" : "r_source"
}